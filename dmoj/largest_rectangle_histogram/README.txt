La solución hará lo siguiente, creará un stack y le hará pop y push a todas las alturas en alguna secuencia de operaciones, esto es O(n), describo como hacerlo a continuación: 
 
Si la pila está vacía o el elemento que está en el tope es menor o igual que la altura actual le voy a hacer push, else le voy a hacer pop a lo que esté en la pila hasta que se cumplan una de las dos condiciones anteriores. Finalmente si después de haberle hecho push a todas las alturas quedan en la pila algunas alturas les voy a hacer pop. De esta forma todas las alturas son push y pop exactamente una vez y el costo de realizar eso es O(n). 

Ahora en el momento en que le hago pop a cada una de las alturas (se lo hago a todas por lo anterior) calculo el área del rectángulo que determina esa altura y lo comparo con el máximo que tengo hasta ahora, entonces la complejidad del algoritmo es O( n*(tiempo calcular área rectángulo para cada altura) ). El siguiente algoritmo realiza lo anterior en tiempo constante.

Para lograrlo voy a guardar en la pila en vez de las alturas directamente una tupla de dos enteros, donde uno es la altura y el otro elemento va a satisfacer que cuando esa altura esté en el tope de la pila, el elemento va a representar la cantidad de alturas que han sido poped por encima de él previamente. ** Asumiendo que en tiempo cte pueda garantizar lo anterior**, notar que cuando esa altura es poped el aŕea del rectángulo sería su altura por la cantidad de elementos poped previamente +1.

+1 para contarlo a el, y además más la cantidad de elementos poped previamente que sería las rectángulos válidos a la derecha, notar que cuando el está en el tope de la pila y es poped es porque either no hay más alturas o la que sigue es menor que ella que está en el tope, análogamente la altura que está antes en la pila es menor o igual que ella por tanto no se cuenta.

La conclusión es como llevar en tiempo constante la cantidad de elementos poped previamente, la idea es la siguiente, inicialmente hago el primer push con valor altura[0] y 0, por lo que inicialmente se cumple, voy a demostrar que a medida que el algoritmo se realiza se mantiene, lo que modifica el stack son los push y los pop, ahora, para hacer un push primero ponemos al stack en estado válido, si es necesario hacerle pop a algún elemento entonces el valor de ese elemento se le debe transferir a el elemento que va a ocupar el tope de la pila, que puede ser la altura que vamos a insertar o el elemento que quedó en el tope de la pila, en cualquiera de los dos casos le sumamos 1 para tener en cuenta el elemento que acabamos de hacerle pop, esto garantiza lo anterior, cuando hacemos push le ponemos 0 + valor ultimo en la pila, notar que esto mantiene la invariante en tiempo constante.
